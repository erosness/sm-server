(module dlna-sql (set-db! browse search)

(import chicken scheme data-structures srfi-1 srfi-13)

(use (except sql-de-lite reset))

;;; dlna-sql -- browse and search databases generated by miniDLNA
(define *db* #f)
(define (set-db! db-path)
  (set! *db* db-path))

;; Statements
(define base-string (conc "SELECT o.OBJECT_ID, o.CLASS, o.NAME, d.DURATION, d.ARTIST, "
                          "d.ALBUM, d.PATH from OBJECTS o left join DETAILS d on (d.ID = o.DETAIL_ID) "))

(define browse-string (conc base-string "where PARENT_ID = ? limit ? offset ?"))
(define (browse-stmt db) (sql db browse-string))

;; nested SELECT keeps sqlite from concatenating the query string for
;; each row. see: http://sqlite.1065341.n5.nabble.com/LIKE-operator-with-prepared-statements-td8553.html
(define search-string (conc base-string
                            "where OBJECT_ID glob '*$*' and o.CLASS = 'item.audioItem.musicTrack' "
                            "and (d.TITLE like (SELECT '%' || ? || '%')) "
                            "group by d.PATH "
                            "limit ? offset ?"))
(define (search-stmt db) (sql db search-string))

;; Transforms
(define (row-> fields row)
  (map (lambda (x y) (cons x y)) fields row))

(define (row->track row)
  (row-> '(id type title duration artist album filename) row))

(define (row->folder row)
  (row-> '(id type name) row))

(define (process-rows rows)
  (filter identity
          (map
           (lambda (row)
             (cond (;; Containers
                    (string-prefix? "container." (cadr row)) (row->folder row))
                   (;; Tracks
                    (equal? "item.audioItem.musicTrack" (cadr row)) (row->track row))
                   (else
                    (print "WARNING: " row " is not a container or track")
                    #f))) rows)))


(define (wrap-db-error thunk)
  (condition-case (thunk)
    (e ()
       (let ((msg ((condition-property-accessor 'exn 'message) e)))
         (warning "error when querying db: " msg)
         #f))))

(define (%do-query stmt #!rest args)
  (wrap-db-error
   (lambda ()
     (call-with-database
      *db* (lambda (db)
             (process-rows (apply query fetch-all (stmt db) args)))))))


;;; Public api
(define (browse #!optional (id 1) (limit 10) (offset 0))
  (%do-query browse-stmt id limit offset))

(define (search q #!optional (limit 10) (offset 0))
  (%do-query search-stmt q limit offset))
)
